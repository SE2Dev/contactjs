"use strict";const DIRECTION_NONE="0",DIRECTION_LEFT="left",DIRECTION_RIGHT="right",DIRECTION_UP="up",DIRECTION_DOWN="down",DIRECTION_CLOCKWISE=1,DIRECTION_COUNTER_CLOCKWISE=-1,DIRECTION_HORIZONTAL=[DIRECTION_LEFT,DIRECTION_RIGHT],DIRECTION_VERTICAL=[DIRECTION_UP,DIRECTION_DOWN],DIRECTION_ALL=[DIRECTION_LEFT,DIRECTION_RIGHT,DIRECTION_UP,DIRECTION_DOWN],GESTURE_STATE_POSSIBLE="possible",GESTURE_STATE_BLOCKED="blocked";class Contact{constructor(t,e){this.DEBUG=!1,this.pointerInputs={},this.activePointerInputs={},this.primaryPointerId=t.pointerId,this.currentPointerEvent=t,this.addPointer(t),this.isActive=!0,this.startTimestamp=t.timeStamp,this.currentTimestamp=this.startTimestamp,this.endTimestamp=null,this.multipointer={liveParameters:{centerMovement:null,centerMovementVector:null,distanceChange:null,relativeDistanceChange:null,rotationAngle:null},globalParameters:{centerMovement:null,centerMovementVector:null,distanceChange:null,relativeDistanceChange:null,rotationAngle:null}}}addPointer(t){this.currentPointerEvent=t;var e=new PointerInput(t);this.pointerInputs[t.pointerId]=e,this.activePointerInputs[t.pointerId]=e}removePointer(t){delete this.activePointerInputs[t]}getPointerInput(t){if(this.pointers.hasOwnProperty(t)){return this.pointers[t]}throw new Error("invalid pointerId: "+t+". Pointer not found in Contact.pointers")}getPrimaryPointerInput(){return this.pointerInputs[this.primaryPointerId]}onPointerMove(t){this.currentPointerEvent=t,this.currentTimestamp=t.timeStamp,this.pointerInputs[t.pointerId].onMove(t),!0===this.DEBUG&&console.log(this.pointerInputs),this.updateState()}onPointerUp(t){var e=t.pointerId;this.currentPointerEvent=t,this.currentTimestamp=t.timeStamp,this.pointerInputs[e].onUp(t),this.removePointer(e),this.updateState()}onPointerCancel(t){this.onPointerUp(pointerupEvent),1==this.DEBUG&&console.log("[Contact] pointercancel detected")}onPointerOut(t){this.onPointerUp(t),1==this.DEBUG&&console.log("[Contact] pointerout detected")}updateState(){var t=!1;Object.keys(this.activePointerInputs).length>0&&(t=!0),this.isActive=t,0==this.isActive?this.endTimestamp=this.currentTimestamp:Object.keys(this.activePointerInputs).length>=2&&this.updateMultipointerParameters()}updateMultipointerParameters(){var t=Object.keys(this.activePointerInputs)[0],e=this.activePointerInputs[t],i=Object.keys(this.activePointerInputs)[1],n=this.activePointerInputs[i],r=e.liveParameters.vector,s=n.liveParameters.vector;if(null!=r&&null!=s){var a=getCenter(r.startPoint,s.startPoint);this.multipointer.liveParameters.center=a;var o=this.calculateCenterMovement(r,s);this.multipointer.liveParameters.centerMovementVector=o,this.multipointer.liveParameters.centerMovement=o.vectorLength;var l=this.calculateDistanceChange(r,s);this.multipointer.liveParameters.distanceChange=l.absolute,this.multipointer.liveParameters.relativeDistanceChange=l.relative;var c=this.calculateAngle(r,s);this.multipointer.liveParameters.rotationAngle=c}var u=e.globalParameters.vector,h=n.globalParameters.vector;if(null!=u&&null!=h){var v=getCenter(u.startPoint,h.startPoint);this.multipointer.globalParameters.center=v;var p=this.calculateCenterMovement(u,h);this.multipointer.globalParameters.centerMovementVector=p,this.multipointer.globalParameters.centerMovement=p.vectorLength;var P=this.calculateDistanceChange(u,h);this.multipointer.globalParameters.distanceChange=P.absolute,this.multipointer.globalParameters.relativeDistanceChange=P.relative;var m=this.calculateAngle(u,h);this.multipointer.globalParameters.rotationAngle=m}!0===this.DEBUG&&(console.log("[Contact] 2 fingers: centerMovement between pointer #"+t+" and pointer #"+i+" : "+this.multipointer.liveParameters.centerMovement+"px"),console.log("[Contact] 2 fingers: distanceChange: between pointer #"+t+" and pointer #"+i+" : "+this.multipointer.liveParameters.distanceChange+"px"),console.log("[Contact] 2 fingers live angle: "+this.multipointer.liveParameters.rotationAngle+"deg"),console.log("[Contact] 2 fingers global angle: "+this.multipointer.globalParameters.rotationAngle+"deg"))}calculateCenterMovement(t,e){var i=getCenter(t.startPoint,e.startPoint),n=getCenter(t.endPoint,e.endPoint);return new Vector(i,n)}calculateDistanceChange(t,e){var i=new Vector(t.startPoint,e.startPoint),n=new Vector(t.endPoint,e.endPoint);return{absolute:n.vectorLength-i.vectorLength,relative:n.vectorLength/i.vectorLength}}calculateAngle(t,e){var i=new Vector(t.startPoint,e.startPoint),n=new Vector(t.endPoint,e.endPoint),r=new Point(0,0),s=new Vector(i.startPoint,r),a=translatePoint(i.endPoint,s),o=(new Vector(r,a),new Vector(n.startPoint,r)),l=translatePoint(n.endPoint,o),c=(new Vector(r,l),-1*calcAngleRad(a)),u=a.x*Math.cos(c)-a.y*Math.sin(c),h=Math.round(a.x*Math.sin(c)+a.y*Math.cos(c)),v=(new Vector(r,new Point(u,h)),l.x*Math.cos(c)-l.y*Math.sin(c)),p=Math.round(l.x*Math.sin(c)+l.y*Math.cos(c));new Vector(r,new Point(v,p));return 180*Math.atan2(p,v)/Math.PI}}class PointerInput{constructor(t,e){this.DEBUG=!1;e=e||{};this.pointerId=t.pointerId,this.vectorTimespan=e.hasOwnProperty("vectorTimespan")?e.vectorTimespan:100,this.initialPointerEvent=t,this.currentPointerEvent=t,this.recognizedEvents=[t],this.canceled=!1,this.isActive=!0,this.liveParameters={vector:null,speed:0,isMoving:!1},this.globalParameters={startX:this.initialPointerEvent.clientX,startY:this.initialPointerEvent.clientY,vector:null,deltaX:0,deltaY:0,startTimestamp:this.initialPointerEvent.timeStamp,currentTimestamp:this.initialPointerEvent.timeStamp,endTimestamp:null,maximumSpeed:0,averageSpeed:0,finalSpeed:null,traveledDistance:0,hasBeenMoved:!1,duration:0}}onMove(t){this.globalParameters.hasBeenMoved=!0,this.liveParameters.isMoving=!0,this.update(t,!0)}onUp(t){this.globalParameters.finalSpeed=this.liveParameters.speed,this.liveParameters.currentSpeed=0,this.liveParameters.isMoving=!1,this.isActive=!1,this.globalParameters.endTimestamp=t.timeStamp,this.update(t),!0===this.DEBUG&&console.log("[Contact] pointerdown ended. pointerdown duration: "+this.globalParameters.duration+"ms")}onCancel(t){this.update(t),this.liveParameters.speed=0,this.canceled=!0,this.liveParameters.isMoving=!1,this.isActive=!1,this.globalParameters.endTimestamp=t.timeStamp,!0===this.DEBUG&&console.log("[Contact] canceled, pointerdown duration:"+this.duration)}update(t){this.currentPointerEvent=t,this.recognizedEvents.push(t);var e=this.getTimedPointerEvents(),i=this.getVector(e[0],e[1]);if(this.liveParameters.vector=i,null!=i){this.liveParameters.speed=this.getSpeed(i,e[0].timeStamp,e[1].timeStamp),this.liveParameters.speed>this.globalParameters.maximumSpeed&&(this.globalParameters.maximumSpeed=this.liveParameters.speed),this.globalParameters.currentTimestamp=t.timeStamp,this.globalParameters.duration=t.timeStamp-this.globalParameters.startTimestamp,this.globalParameters.deltaX=i.endPoint.x-this.globalParameters.startX,this.globalParameters.deltaY=i.endPoint.y-this.globalParameters.startY;var n=this.getVector(this.initialPointerEvent,this.currentPointerEvent);this.globalParameters.vector=n,!0===this.DEBUG&&(console.log("[Contact] current speed: "+this.liveParameters.speed+"px/s"),console.log("[Contact] pointerdown duration: "+this.globalParameters.duration+"ms"),console.log("[Contact] live vector length within vectorTimespan: "+this.liveParameters.vector.vectorLength+"px"))}}getTimedPointerEvents(){for(var t=this.initialPointerEvent,e=this.recognizedEvents[this.recognizedEvents.length-1],i=[],n=this.recognizedEvents.length-1,r=0,s=e.timeStamp;r<this.vectorTimespan&&!((n-=1)<0);)t=this.recognizedEvents[n],i.unshift(t),r=s-t.timeStamp;var a=[t,e];return this.recognizedEvents=i,a}getVector(t,e){var i=null;if(null!=t&&null!=e){let n=new Point(t.clientX,t.clientY),r=new Point(e.clientX,e.clientY);i=new Vector(n,r)}return i}getSpeed(t,e,i){!0===this.DEBUG&&(console.log("[PointerInput vector] "+t),console.log("[PointerInput startTimestamp] "+e),console.log("[PointerInput endTimestamp] "+i));var n=0,r=(i-e)/1e3;return null!=t&&0!=r&&(n=t.vectorLength/r),n}}class Point{constructor(t,e){this.x=t,this.y=e}}class Vector{constructor(t,e){this.startPoint=t,this.endPoint=e,this.direction=DIRECTION_NONE,this.deltaX=this.endPoint.x-this.startPoint.x,this.deltaY=this.endPoint.y-this.startPoint.y,this.x=this.deltaX,this.y=this.deltaY,this.vectorLength=Math.sqrt(Math.pow(this.deltaX,2)+Math.pow(this.deltaY,2)),Math.abs(this.deltaX)>Math.abs(this.deltaY)?this.startPoint.x<this.endPoint.x?this.direction=DIRECTION_RIGHT:this.direction=DIRECTION_LEFT:this.startPoint.y>this.endPoint.y?this.direction=DIRECTION_UP:this.direction=DIRECTION_DOWN}}function deg2rad(t){return Math.PI/180*t}function rad2deg(t){return t/(Math.PI/180)}function getCenter(t,e){var i=(t.x+e.x)/2,n=(t.y+e.y)/2;return new Point(i,n)}function translatePoint(t,e){var i=t.x+e.x,n=t.y+e.y;return new Point(i,n)}function calcAngleDegrees(t){var e=180*Math.atan2(t.y,t.x)/Math.PI;return e<0&&(e=360+e),e}function calcAngleRad(t){var e=Math.atan2(t.y,t.x);return e<0&&(e=2*Math.PI+e),e}class Gesture{constructor(t,e){this.DEBUG=!1,this.domElement=t,this.isActive=!1,this.state=GESTURE_STATE_POSSIBLE,this.initialPointerEvent=null,this.boolParameters={requiresPointerMove:null,requiresActivePointer:null},this.initialMinMaxParameters={pointerCount:[null,null],duration:[null,null],currentSpeed:[null,null],averageSpeed:[null,null],finalSpeed:[null,null],distance:[null,null]},this.activeStateMinMaxParameters={pointerCount:[null,null],duration:[null,null],currentSpeed:[null,null],averageSpeed:[null,null],finalSpeed:[null,null],distance:[null,null]},this.possibleEvents=[],this.options=e||{}}validateMinMax(t,e,i){var n=t[e][0],r=t[e][1];return 1==this.DEBUG&&console.log("[Gestures] checking "+e+"[isActive: "+this.isActive.toString()+"] minValue: "+n+", maxValue: "+r+", current value: "+i),null!=n&&null!=i&&i<n?(1==this.DEBUG&&console.log("dismissing min"+this.constructor.name+": required "+e+": "+n+", current value: "+i),!1):!(null!=r&&null!=i&&i>r)||(1==this.DEBUG&&console.log("dismissing max"+this.constructor.name+": required "+e+": "+r+", current value: "+i),!1)}validateBool(t,e){var i=this.boolParameters[t];return null!=i&&null!=e&&i===e||(null==i||(1==this.DEBUG&&console.log("[Gestures] dismissing "+this.constructor.name+": "+t+" required: "+i+", actual value: "+e),!1))}getMinMaxParameters(t){var e=t.getPrimaryPointerInput();return{pointerCount:Object.keys(t.activePointerInputs).length,duration:e.globalParameters.duration,currentSpeed:e.liveParameters.speed,averageSpeed:e.globalParameters.averageSpeed,finalSpeed:e.globalParameters.finalSpeed,distance:e.liveParameters.vector.vectorLength}}getBoolParameters(t){var e=t.getPrimaryPointerInput();return{requiresPointerUp:!1===e.isActive,requiresActivePointer:!0===e.isActive,requiresPointerMove:!0===e.globalParameters.hasBeenMoved}}validate(t){var e=t.getPrimaryPointerInput();this.possibleEvents=[],1==this.DEBUG&&console.log("[Gestures] running recognition for "+this.constructor.name);var i=this.getBoolParameters(t);for(let t in this.boolParameters){let e=i[t];if(0==this.validateBool(t,e))return!1}var n,r=this.getMinMaxParameters(t);n=1==this.isActive?this.activeStateMinMaxParameters:this.initialMinMaxParameters;for(let t in n){let e=r[t];if(0==this.validateMinMax(n,t,e))return!1}if(this.options.hasOwnProperty("supportedDirections")&&this.options.supportedDirections.length>0&&-1==this.options.supportedDirections.indexOf(e.liveParameters.vector.direction))return 1==this.DEBUG&&console.log("[Gestures] dismissing "+this.constructor.name+": supported directions: "+this.options.supportedDirections+", current direction: "+e.liveParameters.vector.direction),!1;let s=this.constructor.name.toLowerCase();if(this.possibleEvents.push(s),this.options.hasOwnProperty("supportedDirections")&&this.options.supportedDirections.length>0&&this.options.supportedDirections.indexOf(e.liveParameters.vector.direction)>=0){let t=s+e.liveParameters.vector.direction;this.possibleEvents.push(t)}return!0}recognize(t){var e=this.validate(t);1==e&&0==this.isActive&&this.onStart(t),1==e&&this.state==GESTURE_STATE_POSSIBLE?this.emit(t):1==this.isActive&&0==e&&this.onEnd(t)}getEventData(t){return{contact:t,recognizer:this}}emit(t){var e=this.constructor.name.toLowerCase();!0===this.DEBUG&&console.log("[Gestures] detected and firing event "+e);var i=this.getEventData(t),n=new CustomEvent(e,{detail:i});this.domElement.dispatchEvent(n)}onStart(t){this.isActive=!0,this.initialPointerEvent=t.currentPointerEvent;var e=this.constructor.name.toLowerCase()+"start";!0===this.DEBUG&&console.log("[Gestures] firing event: "+e);var i=this.getEventData(t),n=new CustomEvent(e,{detail:i});this.domElement.dispatchEvent(n)}onEnd(t){this.isActive=!1;var e=this.constructor.name.toLowerCase()+"end";!0===this.DEBUG&&console.log("[Gestures] firing event: "+e);let i=this.getEventData(t);var n=new CustomEvent(e,{detail:i});this.domElement.dispatchEvent(n)}}class SinglePointerGesture extends Gesture{constructor(t,e){super(t,e=e||{})}getEventData(t){var e=super.getEventData(t),i=t.getPrimaryPointerInput(),n=new Point(this.initialPointerEvent.clientX,this.initialPointerEvent.clientY),r=new Point(t.currentPointerEvent.clientX,t.currentPointerEvent.clientY),s=new Vector(n,r),a=t.currentPointerEvent.timeStamp-this.initialPointerEvent.timeStamp;return e.global={deltaX:s.x,deltaY:s.y,distance:s.vectorLength,speedX:s.x/a,speedY:s.y/a,speed:s.vectorLength/a,direction:s.direction,scale:1,rotation:0,srcEvent:t.currentPointerEvent},e.live={deltaX:i.liveParameters.vector.x,deltaY:i.liveParameters.vector.y,distance:i.liveParameters.vector.vectorLength,speedX:i.liveParameters.vector.x/t.vectorTimespan,speedY:i.liveParameters.vector.y/t.vectorTimespan,speed:i.liveParameters.speed,direction:i.liveParameters.vector.direction,scale:1,rotation:0,center:{x:i.liveParameters.vector.endPoint.x,y:i.liveParameters.vector.endPoint.y},srcEvent:t.currentPointerEvent},e}}class Pan extends SinglePointerGesture{constructor(t,e){super(t,e=e||{}),this.initialMinMaxParameters.pointerCount=[1,1],this.initialMinMaxParameters.duration=[0,null],this.initialMinMaxParameters.distance=[10,null],this.activeStateMinMaxParameters.pointerCount=[1,1],this.boolParameters.requiresPointerMove=!0,this.boolParameters.requiresActivePointer=!0,this.swipeFinalSpeed=600,this.isSwipe=!1,e.hasOwnProperty("supportedDirections")||(this.options.supportedDirections=DIRECTION_ALL)}validate(t){return 1==this.isActive&&(this.options.supportedDirections=DIRECTION_ALL),super.validate(t)}onStart(t){this.isSwipe=!1,super.onStart(t)}onEnd(t){var e=t.getPrimaryPointerInput();this.swipeFinalSpeed<e.globalParameters.finalSpeed&&(console.log("swipe"),this.isSwipe=!0),super.onEnd(t)}}class Tap extends SinglePointerGesture{constructor(t,e){super(t,e=e||{}),this.initialMinMaxParameters.pointerCount=[0,0],this.initialMinMaxParameters.duration=[0,200],this.initialMinMaxParameters.distance=[null,30],this.boolParameters.requiresPointerMove=!1,this.boolParameters.requiresActivePointer=!1}onStart(t){this.initialPointerEvent=t.currentPointerEvent}}class MultiPointerGesture extends Gesture{constructor(t,e){super(t,e=e||{}),this.boolParameters={requiresPointerMove:null,requiresActivePointer:null},this.initialMinMaxParameters={pointerCount:[2,null]},this.activeStateMinMaxParameters={pointerCount:[2,null]},this.possibleEvents=[],this.options=e||{}}}class TwoPointerGesture extends MultiPointerGesture{constructor(t,e){super(t,e=e||{}),this.boolParameters.requiresPointerMove=!0,this.boolParameters.requiresActivePointer=!0,this.initialMinMaxParameters.pointerCount=[2,2],this.initialMinMaxParameters.centerMovement=[null,null],this.initialMinMaxParameters.distanceChange=[null,null],this.initialMinMaxParameters.rotationAngle=[null,null],this.activeStateMinMaxParameters.pointerCount=[2,2],this.activeStateMinMaxParameters.centerMovement=[null,null],this.activeStateMinMaxParameters.distanceChange=[null,null],this.activeStateMinMaxParameters.rotationAngle=[null,null]}getMinMaxParameters(t){var e=super.getMinMaxParameters(t);return e.centerMovement=t.multipointer.liveParameters.centerMovement,e.distanceChange=Math.abs(t.multipointer.liveParameters.distanceChange),e.rotationAngle=Math.abs(t.multipointer.globalParameters.rotationAngle),e}}class Pinch extends TwoPointerGesture{constructor(t,e){super(t,e=e||{}),this.initialMinMaxParameters.centerMovement=[0,500],this.initialMinMaxParameters.distanceChange=[5,null],this.initialMinMaxParameters.rotationAngle=[null,20]}}class Rotate extends TwoPointerGesture{constructor(t,e){super(t,e=e||{}),this.initialMinMaxParameters.centerMovement=[0,500],this.initialMinMaxParameters.distanceChange=[null,500],this.initialMinMaxParameters.rotationAngle=[5,null]}}class TwoFingerPan extends TwoPointerGesture{constructor(t,e){super(t,e=e||{}),this.initialMinMaxParameters.centerMovement=[10,null],this.initialMinMaxParameters.distanceChange=[null,5],this.initialMinMaxParameters.rotationAngle=[null,null]}}var ALL_GESTURE_CLASSES=[Tap,Pan,Pinch,Rotate,TwoFingerPan];class PointerListener{constructor(t,e){this.DEBUG=!1;var i=this,n=(e=e||{},ALL_GESTURE_CLASSES);this.options={supportedGestures:[]},e.hasOwnProperty("supportedGestures")&&(n=e.supportedGestures);for(let e=0;e<n.length;e++){let i=new(0,n[e])(t);this.options.supportedGestures.push(i)}this.domElement=t,this.contact=null,t.addEventListener("pointerdown",function(t){null==i.contact||0==i.contact.isActive?i.contact=new Contact(t):i.contact.addPointer(t),i.options.hasOwnProperty("pointerdown")&&i.options.pointerdown(t,i)},{passive:!0}),t.addEventListener("pointermove",function(t){null!=i.contact&&1==i.contact.isActive&&(i.contact.onPointerMove(t),i.recognizeGestures(),i.options.hasOwnProperty("pointermove")&&i.options.pointermove(t,i))},{passive:!0}),t.addEventListener("pointerup",function(t){null!=i.contact&&1==i.contact.isActive&&(i.contact.onPointerUp(t),i.recognizeGestures(),i.options.hasOwnProperty("pointerup")&&i.options.pointerup(t,i))}),t.addEventListener("pointerout",function(t){null!=i.contact&&1==i.contact.isActive&&(i.contact.onPointerOut(t),i.recognizeGestures())}),t.addEventListener("pointercancel",function(t){i.contact.onPointerCancel(t),i.recognizeGestures(),i.options.hasOwnProperty("pointercancel")&&i.options.pointercancel(t,i)},{passive:!0})}recognizeGestures(){for(let t=0;t<this.options.supportedGestures.length;t++){this.options.supportedGestures[t].recognize(this.contact)}}}