"use strict";const DIRECTION_NONE="0",DIRECTION_LEFT="left",DIRECTION_RIGHT="right",DIRECTION_UP="up",DIRECTION_DOWN="down",DIRECTION_CLOCKWISE=1,DIRECTION_COUNTER_CLOCKWISE=-1,DIRECTION_HORIZONTAL=[DIRECTION_LEFT,DIRECTION_RIGHT],DIRECTION_VERTICAL=[DIRECTION_UP,DIRECTION_DOWN],DIRECTION_ALL=[DIRECTION_LEFT,DIRECTION_RIGHT,DIRECTION_UP,DIRECTION_DOWN],GESTURE_STATE_POSSIBLE="possible",GESTURE_STATE_BLOCKED="blocked";class Contact{constructor(t){this.DEBUG=!1,this.pointerInputs={},this.activePointerInputs={},this.primaryPointerId=t.pointerId,this.initialPointerEvent=t,this.currentPointerEvent=t,this.addPointer(t),this.isActive=!0,this.startTimestamp=t.timeStamp,this.currentTimestamp=this.startTimestamp,this.endTimestamp=null,this.multipointer={liveParameters:{centerMovement:null,centerMovementVector:null,distanceChange:null,relativeDistanceChange:null,rotationAngle:null},globalParameters:{centerMovement:null,centerMovementVector:null,distanceChange:null,relativeDistanceChange:null,rotationAngle:null}}}addPointer(t){this.currentPointerEvent=t;var e=new PointerInput(t);this.pointerInputs[t.pointerId]=e,this.activePointerInputs[t.pointerId]=e}removePointer(t){delete this.activePointerInputs[t]}getPointerInput(t){if(Object.prototype.hasOwnProperty.call(this.pointers,t)){return this.pointers[t]}throw new Error("invalid pointerId: "+t+". Pointer not found in Contact.pointers")}getPrimaryPointerInput(){return this.pointerInputs[this.primaryPointerId]}onPointerMove(t){this.currentPointerEvent=t,this.currentTimestamp=t.timeStamp,this.pointerInputs[t.pointerId].onMove(t),!0===this.DEBUG&&console.log(this.pointerInputs),this.updateState()}onPointerUp(t){var e=t.pointerId;this.currentPointerEvent=t,this.currentTimestamp=t.timeStamp,this.pointerInputs[e].onUp(t),this.removePointer(e),this.updateState()}onPointerCancel(t){this.onPointerUp(t),1==this.DEBUG&&console.log("[Contact] pointercancel detected")}onPointerLeave(t){this.onPointerUp(t),1==this.DEBUG&&console.log("[Contact] pointerleave detected")}onIdle(){for(let t in this.activePointerInputs){this.activePointerInputs[t].onIdle()}}updateState(){var t=!1;Object.keys(this.activePointerInputs).length>0&&(t=!0),this.isActive=t,0==this.isActive?this.endTimestamp=this.currentTimestamp:Object.keys(this.activePointerInputs).length>=2&&this.updateMultipointerParameters()}updateMultipointerParameters(){var t=Object.keys(this.activePointerInputs)[0],e=this.activePointerInputs[t],i=Object.keys(this.activePointerInputs)[1],n=this.activePointerInputs[i],r=e.liveParameters.vector,s=n.liveParameters.vector;if(null!=r&&null!=s){var a=getCenter(r.startPoint,s.startPoint);this.multipointer.liveParameters.center=a;var o=this.calculateCenterMovement(r,s);this.multipointer.liveParameters.centerMovementVector=o,this.multipointer.liveParameters.centerMovement=o.vectorLength;var l=this.calculateDistanceChange(r,s);this.multipointer.liveParameters.distanceChange=l.absolute,this.multipointer.liveParameters.relativeDistanceChange=l.relative;var c=this.calculateAngle(r,s);this.multipointer.liveParameters.rotationAngle=c}var u=e.globalParameters.vector,h=n.globalParameters.vector;if(null!=u&&null!=h){var p=getCenter(u.startPoint,h.startPoint);this.multipointer.globalParameters.center=p;var v=this.calculateCenterMovement(u,h);this.multipointer.globalParameters.centerMovementVector=v,this.multipointer.globalParameters.centerMovement=v.vectorLength;var m=this.calculateDistanceChange(u,h);this.multipointer.globalParameters.distanceChange=m.absolute,this.multipointer.globalParameters.relativeDistanceChange=m.relative;var d=this.calculateAngle(u,h);this.multipointer.globalParameters.rotationAngle=d}!0===this.DEBUG&&(console.log("[Contact] 2 fingers: centerMovement between pointer #"+t+" and pointer #"+i+" : "+this.multipointer.liveParameters.centerMovement+"px"),console.log("[Contact] 2 fingers: distanceChange: between pointer #"+t+" and pointer #"+i+" : "+this.multipointer.liveParameters.distanceChange+"px"),console.log("[Contact] 2 fingers live angle: "+this.multipointer.liveParameters.rotationAngle+"deg"),console.log("[Contact] 2 fingers global angle: "+this.multipointer.globalParameters.rotationAngle+"deg"))}calculateCenterMovement(t,e){var i=getCenter(t.startPoint,e.startPoint),n=getCenter(t.endPoint,e.endPoint);return new Vector(i,n)}calculateDistanceChange(t,e){var i=new Vector(t.startPoint,e.startPoint),n=new Vector(t.endPoint,e.endPoint);return{absolute:n.vectorLength-i.vectorLength,relative:n.vectorLength/i.vectorLength}}calculateAngle(t,e){var i=new Vector(t.startPoint,e.startPoint),n=new Vector(t.endPoint,e.endPoint),r=new Point(0,0),s=new Vector(i.startPoint,r),a=translatePoint(i.endPoint,s),o=new Vector(n.startPoint,r),l=translatePoint(n.endPoint,o),c=-1*calcAngleRad(a),u=l.x*Math.cos(c)-l.y*Math.sin(c),h=Math.round(l.x*Math.sin(c)+l.y*Math.cos(c));return 180*Math.atan2(h,u)/Math.PI}}class PointerInput{constructor(t,e){this.DEBUG=!1,e=e||{};var i=(new Date).getTime();this.pointerId=t.pointerId;var n=Object.prototype.hasOwnProperty.call(e,"vectorTimespan");this.vectorTimespan=1==n?e.vectorTimespan:100,this.initialPointerEvent=t,this.currentPointerEvent=t,this.recognizedEvents=[t],this.canceled=!1,this.isActive=!0;var r=this.getVector(t,t);this.liveParameters={vector:r,speed:0,isMoving:!1},this.globalParameters={startX:this.initialPointerEvent.clientX,startY:this.initialPointerEvent.clientY,vector:r,deltaX:0,deltaY:0,startTimestampUTC:i,startTimestamp:this.initialPointerEvent.timeStamp,currentTimestamp:this.initialPointerEvent.timeStamp,endTimestamp:null,maximumSpeed:0,averageSpeed:0,finalSpeed:null,traveledDistance:0,hasBeenMoved:!1,duration:0}}onIdle(){let t=(new Date).getTime()-this.globalParameters.startTimestampUTC;this.globalParameters.duration=t}onMove(t){this.globalParameters.hasBeenMoved=!0,this.liveParameters.isMoving=!0,this.update(t,!0)}onUp(t){this.globalParameters.finalSpeed=this.liveParameters.speed,this.liveParameters.currentSpeed=0,this.liveParameters.isMoving=!1,this.isActive=!1,this.globalParameters.endTimestamp=t.timeStamp,this.update(t),!0===this.DEBUG&&console.log("[Contact] pointerdown ended. pointerdown duration: "+this.globalParameters.duration+"ms")}onCancel(t){this.update(t),this.liveParameters.speed=0,this.canceled=!0,this.liveParameters.isMoving=!1,this.isActive=!1,this.globalParameters.endTimestamp=t.timeStamp,!0===this.DEBUG&&console.log("[Contact] canceled, pointerdown duration:"+this.duration)}update(t){this.currentPointerEvent=t,this.recognizedEvents.push(t);var e=this.getTimedPointerEvents(),i=this.getVector(e[0],e[1]);if(this.liveParameters.vector=i,null!=i){this.liveParameters.speed=this.getSpeed(i,e[0].timeStamp,e[1].timeStamp),this.liveParameters.speed>this.globalParameters.maximumSpeed&&(this.globalParameters.maximumSpeed=this.liveParameters.speed),this.globalParameters.currentTimestamp=t.timeStamp,this.globalParameters.duration=t.timeStamp-this.globalParameters.startTimestamp,this.globalParameters.deltaX=i.endPoint.x-this.globalParameters.startX,this.globalParameters.deltaY=i.endPoint.y-this.globalParameters.startY;var n=this.getVector(this.initialPointerEvent,this.currentPointerEvent);this.globalParameters.vector=n,!0===this.DEBUG&&(console.log("[Contact] current speed: "+this.liveParameters.speed+"px/s"),console.log("[Contact] pointerdown duration: "+this.globalParameters.duration+"ms"),console.log("[Contact] live vector length within vectorTimespan: "+this.liveParameters.vector.vectorLength+"px"))}}getTimedPointerEvents(){for(var t=this.initialPointerEvent,e=this.recognizedEvents[this.recognizedEvents.length-1],i=this.recognizedEvents.length-1,n=0,r=e.timeStamp;n<this.vectorTimespan&&!((i-=1)<0);)n=r-(t=this.recognizedEvents[i]).timeStamp;var s=[t,e];return this.recognizedEvents=this.recognizedEvents.slice(-20),s}getVector(t,e){var i=null;if(null!=t&&null!=e){let n=new Point(t.clientX,t.clientY),r=new Point(e.clientX,e.clientY);i=new Vector(n,r)}return i}getSpeed(t,e,i){!0===this.DEBUG&&(console.log("[PointerInput vector] "+t),console.log("[PointerInput startTimestamp] "+e),console.log("[PointerInput endTimestamp] "+i));var n=0,r=(i-e)/1e3;return null!=t&&0!=r&&(n=t.vectorLength/r),n}}class Point{constructor(t,e){this.x=t,this.y=e}}class Vector{constructor(t,e){this.startPoint=t,this.endPoint=e,this.direction=DIRECTION_NONE,this.deltaX=this.endPoint.x-this.startPoint.x,this.deltaY=this.endPoint.y-this.startPoint.y,this.x=this.deltaX,this.y=this.deltaY,this.vectorLength=Math.sqrt(Math.pow(this.deltaX,2)+Math.pow(this.deltaY,2)),Math.abs(this.deltaX)>Math.abs(this.deltaY)?this.startPoint.x<this.endPoint.x?this.direction=DIRECTION_RIGHT:this.direction=DIRECTION_LEFT:this.startPoint.y<this.endPoint.y?this.direction=DIRECTION_UP:this.direction=DIRECTION_DOWN}}function deg2rad(t){return Math.PI/180*t}function rad2deg(t){return t/(Math.PI/180)}function getCenter(t,e){var i=(t.x+e.x)/2,n=(t.y+e.y)/2;return new Point(i,n)}function translatePoint(t,e){var i=t.x+e.x,n=t.y+e.y;return new Point(i,n)}function calcAngleDegrees(t){var e=180*Math.atan2(t.y,t.x)/Math.PI;return e<0&&(e=360+e),e}function calcAngleRad(t){var e=Math.atan2(t.y,t.x);return e<0&&(e=2*Math.PI+e),e}class Gesture{constructor(t,e){this.DEBUG=!0,this.domElement=t,this.isActive=!1,this.state=GESTURE_STATE_POSSIBLE,this.initialPointerEvent=null,this.boolParameters={requiresPointerMove:null,requiresActivePointer:null},this.initialMinMaxParameters={pointerCount:[null,null],duration:[null,null],currentSpeed:[null,null],averageSpeed:[null,null],finalSpeed:[null,null],distance:[null,null]},this.activeStateMinMaxParameters={pointerCount:[null,null],duration:[null,null],currentSpeed:[null,null],averageSpeed:[null,null],finalSpeed:[null,null],distance:[null,null]};let i={bubbles:!0};this.options=e||{};for(let t in i)t in this.options||(this.options[t]=i[t])}validateMinMax(t,e,i){var n=t[e][0],r=t[e][1];return 1==this.DEBUG&&console.log("[Gestures] checking "+e+"[gesture.isActive: "+this.isActive.toString()+"] minValue: "+n+", maxValue: "+r+", current value: "+i),null!=n&&null!=i&&i<n?(1==this.DEBUG&&console.log("dismissing min"+this.constructor.name+": required "+e+": "+n+", current value: "+i),!1):!(null!=r&&null!=i&&i>r)||(1==this.DEBUG&&console.log("dismissing max"+this.constructor.name+": required "+e+": "+r+", current value: "+i),!1)}validateBool(t,e){var i=this.boolParameters[t];return null!=i&&null!=e&&i===e||(null==i||(1==this.DEBUG&&console.log("[Gestures] dismissing "+this.constructor.name+": "+t+" required: "+i+", actual value: "+e),!1))}getMinMaxParameters(t){var e=t.getPrimaryPointerInput();return{pointerCount:Object.keys(t.activePointerInputs).length,duration:e.globalParameters.duration,currentSpeed:e.liveParameters.speed,averageSpeed:e.globalParameters.averageSpeed,finalSpeed:e.globalParameters.finalSpeed,distance:e.liveParameters.vector.vectorLength}}getBoolParameters(t){var e=t.getPrimaryPointerInput();return{requiresPointerUp:!1===e.isActive,requiresActivePointer:!0===e.isActive,requiresPointerMove:!0===e.globalParameters.hasBeenMoved}}validate(t){var e=t.getPrimaryPointerInput();1==this.DEBUG&&console.log("[Gestures] running recognition for "+this.constructor.name);var i=this.getBoolParameters(t);for(let t in this.boolParameters){let e=i[t];if(0==this.validateBool(t,e))return!1}var n,r=this.getMinMaxParameters(t);n=1==this.isActive?this.activeStateMinMaxParameters:this.initialMinMaxParameters;for(let t in n){let e=r[t];if(0==this.validateMinMax(n,t,e))return!1}return!(1==Object.prototype.hasOwnProperty.call(this.options,"supportedDirections")&&this.options.supportedDirections.length>0&&-1==this.options.supportedDirections.indexOf(e.liveParameters.vector.direction))||(1==this.DEBUG&&console.log("[Gestures] dismissing "+this.constructor.name+": supported directions: "+this.options.supportedDirections+", current direction: "+e.liveParameters.vector.direction),!1)}recognize(t){var e=this.validate(t);1==e&&0==this.isActive&&this.onStart(t),1==e&&this.state==GESTURE_STATE_POSSIBLE?this.emit(t):1==this.isActive&&0==e&&this.onEnd(t)}getEventData(t){return{contact:t,recognizer:this}}emit(t,e){e=e||this.constructor.name.toLowerCase(),!0===this.DEBUG&&console.log("[Gestures] detected and firing event "+e);var i=this.getEventData(t),n={detail:i,bubbles:this.options.bubbles},r=new CustomEvent(e,n),s=t.initialPointerEvent.target;1==n.bubbles?s.dispatchEvent(r):this.domElement.dispatchEvent(r);var a=i.live.direction;if(1==Object.prototype.hasOwnProperty.call(this.options,"supportedDirections"))for(let t=0;t<this.options.supportedDirections.length;t++){let i=this.options.supportedDirections[t];if(i==a){let t=e+i;1==this.DEBUG&&console.log("[Gestures] detected and firing event "+t);let r=new CustomEvent(t,n);1==n.bubbles?s.dispatchEvent(r):this.domElement.dispatchEvent(r)}}}onStart(t){this.isActive=!0,this.initialPointerEvent=t.currentPointerEvent;var e=this.constructor.name.toLowerCase()+"start";!0===this.DEBUG&&console.log("[Gestures] firing event: "+e);var i=this.getEventData(t),n=new CustomEvent(e,{detail:i});this.domElement.dispatchEvent(n)}onEnd(t){this.isActive=!1;var e=this.constructor.name.toLowerCase()+"end";!0===this.DEBUG&&console.log("[Gestures] firing event: "+e);let i=this.getEventData(t);var n=new CustomEvent(e,{detail:i});this.domElement.dispatchEvent(n)}onTouchStart(){}onTouchMove(){}onTouchEnd(){}onTouchCancel(){}}class SinglePointerGesture extends Gesture{constructor(t,e){super(t,e=e||{})}getEventData(t){var e=super.getEventData(t),i=t.getPrimaryPointerInput(),n=new Point(this.initialPointerEvent.clientX,this.initialPointerEvent.clientY),r=new Point(t.currentPointerEvent.clientX,t.currentPointerEvent.clientY),s=new Vector(n,r),a=t.currentPointerEvent.timeStamp-this.initialPointerEvent.timeStamp;return e.global={deltaX:s.x,deltaY:s.y,distance:s.vectorLength,speedX:s.x/a,speedY:s.y/a,speed:s.vectorLength/a,direction:s.direction,scale:1,rotation:0,srcEvent:t.currentPointerEvent},e.live={deltaX:i.liveParameters.vector.x,deltaY:i.liveParameters.vector.y,distance:i.liveParameters.vector.vectorLength,speedX:i.liveParameters.vector.x/t.vectorTimespan,speedY:i.liveParameters.vector.y/t.vectorTimespan,speed:i.liveParameters.speed,direction:i.liveParameters.vector.direction,scale:1,rotation:0,center:{x:i.liveParameters.vector.endPoint.x,y:i.liveParameters.vector.endPoint.y},srcEvent:t.currentPointerEvent},e}}class Pan extends SinglePointerGesture{constructor(t,e){super(t,e=e||{}),this.initialMinMaxParameters.pointerCount=[1,1],this.initialMinMaxParameters.duration=[0,null],this.initialMinMaxParameters.distance=[20,null],this.activeStateMinMaxParameters.pointerCount=[1,1],this.boolParameters.requiresPointerMove=!0,this.boolParameters.requiresActivePointer=!0,this.swipeFinalSpeed=600,this.isSwipe=!1,this.initialSupportedDirections=DIRECTION_ALL,Object.prototype.hasOwnProperty.call(e,"supportedDirections")?this.initialSupportedDirections=e.supportedDirections:this.options.supportedDirections=DIRECTION_ALL}validate(t){return 1==this.isActive&&(this.options.supportedDirections=DIRECTION_ALL),super.validate(t)}onStart(t){this.isSwipe=!1,super.onStart(t)}onEnd(t){var e=t.getPrimaryPointerInput();this.swipeFinalSpeed<e.globalParameters.finalSpeed&&(this.isSwipe=!0,this.emit(t,"swipe")),super.onEnd(t),this.options.supportedDirections=this.initialSupportedDirections}onTouchMove(t){1==this.isActive&&(1==this.DEBUG&&console.log("[Pan] preventing touchmove default"),t.preventDefault(),t.stopPropagation())}}class Tap extends SinglePointerGesture{constructor(t,e){super(t,e=e||{}),this.initialMinMaxParameters.pointerCount=[0,0],this.initialMinMaxParameters.duration=[0,200],this.initialMinMaxParameters.distance=[null,30],this.boolParameters.requiresPointerMove=null,this.boolParameters.requiresActivePointer=!1}onStart(t){this.initialPointerEvent=t.currentPointerEvent}}class Press extends SinglePointerGesture{constructor(t,e){super(t,e=e||{}),this.initialMinMaxParameters.pointerCount=[1,1],this.initialMinMaxParameters.duration=[600,null],this.initialMinMaxParameters.distance=[null,30],this.boolParameters.requiresPointerMove=null,this.boolParameters.requiresActivePointer=!0,this.hasBeenEmitted=!1}getMinMaxParameters(t){var e=super.getMinMaxParameters(t),i=t.getPrimaryPointerInput();return e.distance=i.globalParameters.vector.vectorLength,e}recognize(t){if(1==this.validate(t)&&0==this.hasBeenEmitted)this.initialPointerEvent=t.currentPointerEvent,this.emit(t),this.hasBeenEmitted=!0;else{let e=t.getPrimaryPointerInput().globalParameters.duration;1==this.hasBeenEmitted&&e<=this.initialMinMaxParameters.duration[0]&&(this.hasBeenEmitted=!1)}}}class MultiPointerGesture extends Gesture{constructor(t,e){super(t,e=e||{}),this.boolParameters={requiresPointerMove:null,requiresActivePointer:null},this.initialMinMaxParameters={pointerCount:[2,null]},this.activeStateMinMaxParameters={pointerCount:[2,null]},this.options=e||{}}}class TwoPointerGesture extends MultiPointerGesture{constructor(t,e){super(t,e=e||{}),this.boolParameters.requiresPointerMove=!0,this.boolParameters.requiresActivePointer=!0,this.initialMinMaxParameters.pointerCount=[2,2],this.initialMinMaxParameters.centerMovement=[null,null],this.initialMinMaxParameters.distanceChange=[null,null],this.initialMinMaxParameters.rotationAngle=[null,null],this.activeStateMinMaxParameters.pointerCount=[2,2],this.activeStateMinMaxParameters.centerMovement=[null,null],this.activeStateMinMaxParameters.distanceChange=[null,null],this.activeStateMinMaxParameters.rotationAngle=[null,null]}getMinMaxParameters(t){var e=super.getMinMaxParameters(t);return e.centerMovement=t.multipointer.liveParameters.centerMovement,e.distanceChange=Math.abs(t.multipointer.liveParameters.distanceChange),e.rotationAngle=Math.abs(t.multipointer.liveParameters.rotationAngle),e}getEventData(t){var e=super.getEventData(t),i=t.currentPointerEvent.timeStamp-this.initialPointerEvent.timeStamp,n=t.multipointer.globalParameters,r=t.multipointer.liveParameters;return e.global={deltaX:n.centerMovementVector.x,deltaY:n.centerMovementVector.y,distance:n.centerMovement,speedX:n.centerMovementVector.x/i,speedY:n.centerMovementVector.y/i,speed:n.centerMovementVector.vectorLength/i,direction:n.centerMovementVector.direction,scale:n.relativeDistanceChange,rotation:n.rotationAngle,srcEvent:t.currentPointerEvent},e.live={deltaX:r.centerMovementVector.x,deltaY:r.centerMovementVector.y,distance:r.centerMovement,speedX:r.centerMovementVector.x/i,speedY:r.centerMovementVector.y/i,speed:r.centerMovementVector.vectorLength/i,direction:r.centerMovementVector.direction,scale:r.relativeDistanceChange,rotation:r.rotationAngle,center:{x:r.centerMovementVector.startPoint.x,y:r.centerMovementVector.startPoint.y},srcEvent:t.currentPointerEvent},e}}class Pinch extends TwoPointerGesture{constructor(t,e){super(t,e=e||{}),this.initialMinMaxParameters.centerMovement=[0,50],this.initialMinMaxParameters.distanceChange=[5,null],this.initialMinMaxParameters.rotationAngle=[null,20]}}class Rotate extends TwoPointerGesture{constructor(t,e){super(t,e=e||{}),this.initialMinMaxParameters.centerMovement=[0,50],this.initialMinMaxParameters.distanceChange=[null,50],this.initialMinMaxParameters.rotationAngle=[5,null]}}class TwoFingerPan extends TwoPointerGesture{constructor(t,e){super(t,e=e||{}),this.initialMinMaxParameters.centerMovement=[5,null],this.initialMinMaxParameters.distanceChange=[null,500],this.initialMinMaxParameters.rotationAngle=[null,null]}}var ALL_GESTURE_CLASSES=[Tap,Press,Pan,Pinch,Rotate,TwoFingerPan];class PointerListener{constructor(t,e){this.DEBUG=!1;var i=this;this.lastRecognitionTimestamp=null,this.idleRecognitionIntervalId=null,e=e||{},this.options={bubbles:!0};for(let t in e)"supportedGestures"!=t&&(this.options[t]=e[t]);var n=ALL_GESTURE_CLASSES,r=[];1==Object.prototype.hasOwnProperty.call(e,"supportedGestures")&&(n=e.supportedGestures);for(let e=0;e<n.length;e++){let i,s=n[e],a={bubbles:this.options.bubbles};if("function"==typeof s)i=new s(t,a);else{if("object"!=typeof s)throw new Error("unsupported gesture type: "+typeof s);i=s}r.push(i)}this.options.supportedGestures=r,this.domElement=t,this.contact=null,t.addEventListener("pointerdown",function(e){t.setPointerCapture(e.pointerId),null==i.contact||0==i.contact.isActive?i.contact=new Contact(e):i.contact.addPointer(e),1==Object.prototype.hasOwnProperty.call(i.options,"pointerdown")&&i.options.pointerdown(e,i),null!=i.idleRecognitionIntervalId&&i.clearIdleRecognitionInterval(),i.idleRecognitionIntervalId=setInterval(function(){i.onIdle()},100)},{passive:!0}),t.addEventListener("pointermove",function(t){null!=i.contact&&1==i.contact.isActive&&(i.contact.onPointerMove(t),i.recognizeGestures(),1==Object.prototype.hasOwnProperty.call(i.options,"pointermove")&&i.options.pointermove(t,i))},{passive:!0}),t.addEventListener("pointerup",function(e){(t.releasePointerCapture(e.pointerId),null!=i.contact&&1==i.contact.isActive)&&(i.contact.onPointerUp(e),i.recognizeGestures(),1==Object.prototype.hasOwnProperty.call(i.options,"pointerup")&&i.options.pointerup(e,i));i.clearIdleRecognitionInterval()}),t.addEventListener("pointerleave",function(t){null!=i.contact&&1==i.contact.isActive&&(i.contact.onPointerLeave(t),i.recognizeGestures()),i.clearIdleRecognitionInterval()}),t.addEventListener("pointercancel",function(e){t.releasePointerCapture(e.pointerId),1==this.DEBUG&&console.log("[PointerListener] pointercancel detected"),i.contact.onPointerCancel(e),i.recognizeGestures(),i.clearIdleRecognitionInterval(),1==Object.prototype.hasOwnProperty.call(i.options,"pointercancel")&&i.options.pointercancel(e,i)},{passive:!0}),this.addTouchListeners()}addTouchListeners(){var t=this;1==t.options.handleTouchEvents&&this.domElement.addEventListener("touchmove",function(e){for(let i=0;i<t.options.supportedGestures.length;i++){t.options.supportedGestures[i].onTouchMove(e)}})}onIdle(){if(1==this.DEBUG&&console.log("[PointerListener] onIdle"),null==this.contact||0==this.contact.isActive)this.clearIdleRecognitionInterval();else{let t=(new Date).getTime(),e=null;null!=this.lastRecognitionTimestamp&&(e=t-this.lastRecognitionTimestamp),(null==e||e>100)&&(this.contact.onIdle(),1==this.DEBUG&&console.log("[PointerListener] run idle recognition"),this.recognizeGestures())}}clearIdleRecognitionInterval(){null!=this.idleRecognitionIntervalId&&(clearInterval(this.idleRecognitionIntervalId),this.idleRecognitionIntervalId=null)}recognizeGestures(){this.lastRecognitionTimestamp=(new Date).getTime();for(let t=0;t<this.options.supportedGestures.length;t++){this.options.supportedGestures[t].recognize(this.contact)}}}